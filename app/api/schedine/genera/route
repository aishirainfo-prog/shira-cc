import { NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase';
export const runtime = 'nodejs';

export async function GET(req: Request) {
  try {
    const url = new URL(req.url);
    const n = Math.max(1, Math.min(10, Number(url.searchParams.get('n') || 5)));

    // Partite di oggi non ancora finite
    const today = new Date();
    const yyyy = today.getUTCFullYear();
    const mm = String(today.getUTCMonth() + 1).padStart(2, '0');
    const dd = String(today.getUTCDate()).padStart(2, '0');
    const from = `${yyyy}-${mm}-${dd}T00:00:00Z`;
    const to = `${yyyy}-${mm}-${dd}T23:59:59Z`;

    const { data: fixtures, error } = await supabase
      .from('fixtures')
      .select('*')
      .gte('start_ts', from)
      .lte('start_ts', to)
      .not('status', 'eq', 'FINISHED')
      .order('start_ts', { ascending: true });

    if (error) throw error;
    if (!fixtures || fixtures.length === 0) {
      return NextResponse.json({ ok: true, demo: true, msg: 'Nessuna partita di oggi in DB. Fai prima /api/sync/fixtures.' });
    }

    const chosen = fixtures.slice(0, n);

    // DEMO: pick casalinga (= "1") con probabilità fissa 0.45
    // (Quando aggiungiamo le quote sostituiremo con vero calcolo/probabilità)
    const picks = chosen.map((f) => ({
      fixture_id: f.id,
      pick: '1',
      price: null,
      prob: 0.45,
      value: null
    }));

    // crea schedina
    const { data: schedinaIns, error: errS } = await supabase
      .from('schedine')
      .insert({ stake: 1, note: 'demo', })
      .select('id')
      .single();

    if (errS) throw errS;

    const schedina_id = schedinaIns.id as string;

    const { error: errVoci } = await supabase
      .from('schedina_voci')
      .insert(picks.map(p => ({ ...p, schedina_id })));

    if (errVoci) throw errVoci;

    return NextResponse.json({
      ok: true,
      demo: true,
      algo_version: 'demo-0.1',
      schedina_id,
      partite: chosen.map(f => ({
        id: f.id, lega: f.league, home: f.home, away: f.away, start_ts: f.start_ts
      })),
      picks
    });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e.message }, { status: 500 });
  }
}
